/*
 * Note: This was generated by Claude,
 * but needed some fixes and simplification.
 * Probably I need to reimplement it from scratch for sake of learning.
 * */
#include "../src/lcthw/list.h" // Include your linked list implementation
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

// Function to measure execution time in microseconds
double measure_execution_time(void (*function)(List *list), List *test_list) {
  struct timeval start, end;

  gettimeofday(&start, NULL);

  // Run the function
  function(test_list);

  gettimeofday(&end, NULL);

  // Calculate time in microseconds
  double time_spent =
      (end.tv_sec - start.tv_sec) * 1e6 + (end.tv_usec - start.tv_usec);
  return time_spent;
}

// Wrapper functions for your algorithms
void run_algorithm1(List *list) {
  // Call your first algorithm implementation with list
  // Example: List_bubble_sort(list);
  List_print_int(list);
}

void run_algorithm2(List *list) {
  // Call your second algorithm implementation with list
  // Example: List_merge_sort(list);
  //usleep(500000);
  usleep(1000);  // 1000 micro == 1 millisecond
}

// Function to create a copy of a list for testing
List *copy_list(List *source) {
  List *copy = List_create();
  LIST_FOREACH(source, first, next, cur) {
    // Note: this would be a shallow copy
    //   since value is of type   void* in our case a pointer to an int
    //   (then we'd get a fatal error, since we free the value twice)
    // List_push(copy, cur->value);
    int *new_value = malloc(sizeof(int));
    *new_value = *(int *)cur->value; // Cast void* to int* to dereference
    List_push(copy, new_value);
  }
  return copy;
}

int main() {
  // Test parameters
  const int NUM_ITERATIONS = 100;
  const int TEST_RUNS = 3;
  const int LIST_SIZE = 1000; // Adjust based on your needs

  // Create original test list
  List *original_list = List_create();

  // Fill the list with test data
  for (int i = 0; i < LIST_SIZE; i++) {
    // Create some test data - adjust based on your implementation
    // This example assumes your list stores integers
    int *value = malloc(sizeof(int));
    *value = rand() % 1000;
    List_push(original_list, value);
  }

  // Run performance tests
  double total_time1 = 0.0;
  double total_time2 = 0.0;

  printf("Running performance comparison (%d iterations, %d test runs)...\n",
         NUM_ITERATIONS, TEST_RUNS);
  printf("List size: %d elements\n", LIST_SIZE);

  for (int run = 0; run < TEST_RUNS; run++) {
    // Time Algorithm 1
    double time1 = 0.0;
    for (int i = 0; i < NUM_ITERATIONS; i++) {
      // Create a fresh copy of test list for each iteration
      List *test_list1 = copy_list(original_list);
      time1 += measure_execution_time(run_algorithm1, test_list1);
      List_clear_destroy(test_list1);
    }

    // Time Algorithm 2
    double time2 = 0.0;
    for (int i = 0; i < NUM_ITERATIONS; i++) {
      List *test_list2 = copy_list(original_list);
      time2 += measure_execution_time(run_algorithm2, test_list2);
      List_clear_destroy(test_list2);
    }

    printf("Run %d: Algorithm 1: %.2f μs, Algorithm 2: %.2f μs\n", run + 1,
           time1, time2);

    total_time1 += time1;
    total_time2 += time2;
  }

  // Calculate and show average results
  double avg_time1 = total_time1 / TEST_RUNS;
  double avg_time2 = total_time2 / TEST_RUNS;

  printf("\nAverage Results:\n");
  printf("Algorithm 1: %.2f μs (%.2f μs per operation)\n", avg_time1,
         avg_time1 / NUM_ITERATIONS);
  printf("Algorithm 2: %.2f μs (%.2f μs per operation)\n", avg_time2,
         avg_time2 / NUM_ITERATIONS);

  if (avg_time1 < avg_time2) {
    printf("Algorithm 1 is %.2f times faster\n", avg_time2 / avg_time1);
  } else {
    printf("Algorithm 2 is %.2f times faster\n", avg_time1 / avg_time2);
  }

  // Clean up
  List_clear_destroy(original_list);

  return 0;
}
