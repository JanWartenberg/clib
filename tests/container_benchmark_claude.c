/*
 * Generated by Claude.
 * At least execution results look highly plausible
 *
 * To compile:
 *  gcc -o container_benchmark container_benchmark_claude.c ../src/lcthw/list.c ../src/lcthw/darray.c -Wall
 *
 * Note: the CLOCK_MONOTONIC lets the LSP whine, but it compiles in Ubuntu Docker.
 *
 * */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "../src/lcthw/list.h"
#include "../src/lcthw/darray.h"

// Define the number of operations for each test
#define NUM_ELEMENTS 100000
#define NUM_OPERATIONS 10000

// Function to get current time in milliseconds
double get_time_ms() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (ts.tv_sec * 1000.0) + (ts.tv_nsec / 1000000.0);
}

// Helper function to create an integer on the heap
int *create_int(int value) {
    int *ptr = malloc(sizeof(int));
    *ptr = value;
    return ptr;
}

// Benchmark for inserting at the beginning
void benchmark_insert_begin() {
    printf("\n--- Benchmark: Insert at Beginning ---\n");
    
    // Setup List
    List *list = List_create();
    
    // Setup DArray
    DArray *array = DArray_create(sizeof(int*), NUM_OPERATIONS);
    
    // Benchmark List_unshift
    double start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        List_unshift(list, create_int(i));
    }
    double list_time = get_time_ms() - start_time;
    
    // Benchmark DArray_insert_begin
    start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        DArray_insert_begin(array, create_int(i));
    }
    double array_time = get_time_ms() - start_time;
    
    printf("List_unshift time: %.2f ms\n", list_time);
    printf("DArray_insert_begin time: %.2f ms\n", array_time);
    printf("Ratio (Array/List): %.2f\n", array_time / list_time);
    
    // Cleanup
    List_clear_destroy(list);
    DArray_clear_destroy(array);
}

// Benchmark for inserting at the end
void benchmark_insert_end() {
    printf("\n--- Benchmark: Insert at End ---\n");
    
    // Setup List
    List *list = List_create();
    
    // Setup DArray
    DArray *array = DArray_create(sizeof(int*), NUM_OPERATIONS);
    
    // Benchmark List_push
    double start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        List_push(list, create_int(i));
    }
    double list_time = get_time_ms() - start_time;
    
    // Benchmark DArray_push
    start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        DArray_push(array, create_int(i));
    }
    double array_time = get_time_ms() - start_time;
    
    printf("List_push time: %.2f ms\n", list_time);
    printf("DArray_push time: %.2f ms\n", array_time);
    printf("Ratio (Array/List): %.2f\n", array_time / list_time);
    
    // Cleanup
    List_clear_destroy(list);
    DArray_clear_destroy(array);
}

// Benchmark for removing from the end
void benchmark_remove_end() {
    printf("\n--- Benchmark: Remove from End ---\n");
    
    // Setup and populate List
    List *list = List_create();
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        List_push(list, create_int(i));
    }
    
    // Setup and populate DArray
    DArray *array = DArray_create(sizeof(int*), NUM_ELEMENTS);
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        DArray_push(array, create_int(i));
    }
    
    // Benchmark List_pop
    double start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        void *item = List_pop(list);
        if (item) free(item);
    }
    double list_time = get_time_ms() - start_time;
    
    // Benchmark DArray_pop
    start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        void *item = DArray_pop(array);
        if (item) free(item);
    }
    double array_time = get_time_ms() - start_time;
    
    printf("List_pop time: %.2f ms\n", list_time);
    printf("DArray_pop time: %.2f ms\n", array_time);
    printf("Ratio (Array/List): %.2f\n", array_time / list_time);
    
    // Cleanup
    List_clear_destroy(list);
    DArray_clear_destroy(array);
}

// Access benchmark (middle element)
void benchmark_access() {
    printf("\n--- Benchmark: Random Access ---\n");
    
    // Setup and populate List
    List *list = List_create();
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        List_push(list, create_int(i));
    }
    
    // Setup and populate DArray
    DArray *array = DArray_create(sizeof(int*), NUM_ELEMENTS);
    for (int i = 0; i < NUM_ELEMENTS; i++) {
        DArray_push(array, create_int(i));
    }
    
    // Benchmark List_get_value (middle elements)
    double start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        int index = NUM_ELEMENTS / 2;  // Middle element
        void *item = List_get_value(list, index);
        // Just access, don't free
    }
    double list_time = get_time_ms() - start_time;
    
    // Benchmark DArray direct access
    start_time = get_time_ms();
    for (int i = 0; i < NUM_OPERATIONS; i++) {
        int index = NUM_ELEMENTS / 2;  // Middle element
        void *item = array->contents[index];
        // Just access, don't free
    }
    double array_time = get_time_ms() - start_time;
    
    printf("List random access time: %.2f ms\n", list_time);
    printf("DArray random access time: %.2f ms\n", array_time);
    printf("Ratio (Array/List): %.2f\n", array_time / list_time);
    
    // Cleanup
    List_clear_destroy(list);
    DArray_clear_destroy(array);
}

int main(int argc, char *argv[]) {
    printf("Running benchmark with %d operations\n", NUM_OPERATIONS);
    
    // Run all benchmarks
    benchmark_insert_begin();
    benchmark_insert_end();
    benchmark_remove_end();
    benchmark_access();
    
    printf("\nBenchmark complete\n");
    return 0;
}
